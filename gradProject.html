<!DOCTYPE html>
<html lang="en">

<head>
    <title>Jake Hafele - Project Portfolio</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="./style/myStyle.css" rel="stylesheet" type="text/css">
    <link rel="icon" href="logo/logo.png">
</head>

<body class="body">

    <div class="content">

        <div class="titleBlock">
            <a>Jake Hafele - Project Portfolio</a>
        </div>

        <div class="pageNav">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="resume.html">Resume</a></li>
                <li class="dropdown">
                    <a href="">Projects</a>
                    <div class="dropdown-content">
                        <a href="freshmanProject.html">Freshman Year</a>
                        <a href="sophomoreProject.html">Sophomore Year</a>
                        <a href="juniorProject.html">Junior Year</a>
                        <a href="seniorProject.html">Senior Year</a>
                        <a href="gradProject.html">Grad School</a>
                    </div>
                </li>
                <li class="dropdown">
                    <a href="">Work Experience</a>
                    <div class="dropdown-content">
                        <a href="intern.html">Internships</a>
                        <a href="TA.html">Teaching Assistant</a>
                    </div>
                </li>
            </ul>
        </div>

        <div class="contentNav">
            <ul>
                <li class="tablinks" onclick="openTab(event, 'tab1')"><a>Chipyard</a></li>
                <li class="tablinks" onclick="openTab(event, 'tab2')"><a>FPGA Task Scheduler</a></li>
                <li class="tablinks" onclick="openTab(event, 'tab3')"><a>OpenFPGA</a></li>
            </ul>
        </div>

        <div class="contentBlock">
            <div id="tab1" class="tabcontent">

                <Header>
                    <a href="chipyard.html">Chipyard FPGA Implementation (Click here for more info)</a>
                </Header>

                <General>

                <img class=picture_centered src="./img/chipyard/speedup.JPG" width="80%" height="80%">

                For my final project in CPRE 581, Computer Systems Architecture, me and two friends from solar car worked on analyzing different branch predictors for an open-source out of order processor, the BOOM core. Our motivation for this project was to further analyzer different branch predictors in the context of area, power, and slack synthesis results for a real FPGA hardware application. Most of the research papers we reviewed in the class were solely focused on prediction accuracy or performance in terms of execution time, with little consideration for area or power consumption. The goal of our paper was to use the open-source framework Chipyard to generate an out of order processor core which could be instantiated on an FPGA to synthesize and reconfigure our multiple BOOM cores with varying branch predictor configurations, such as tournament, GShare, Local, or more. <br><br>
                    
                <h4>Documentation</h4>
                <ul>
                    <li><a href="pdf/Chipyard/Topic_Selection.pdf">Topic Selection</a></li>
                    <li><a href="pdf/Chipyard/Project_Proposal.pdf">Project Proposal</a></li>
                    <li><a href="pdf/Chipyard/Progress_Report.pdf">Progress Report</a></li>
                    <li><a href="pdf/Chipyard/Presentation.pdf">Presentation</a></li>
                    <li><a href="pdf/Chipyard/Final_Report.pdf">Final Report</a></li>
                </ul>

                </General>

            </div>

            <div id="tab2" class="tabcontent">

                <Header>
                    <h3>FPGA Task Scheduler</h3>
                </Header>

                <General>

                    <img class=picture_centered src="./img/fpga_task_scheduler/FPGA_task_scheduler.JPG" width="60%" height="60%">
    

                    In the Fall 2023 semester, I took CPRE 558, Real Time Operating Systems, at Iowa State University. As a final project, me and a partner decided to create a hardware implementation for a periodic RMS scheduler using Verilog RTL and an FPGA implementation. The goal of this project was to design a hardware architecture that could achieve faster and more efficient context switching for tasks in comparison to a software scheduler that was intended for the same task set. <br><br>

                    &#8195;
                    Our design was centered around the 5 stage MIPS processor that we designed in a previous computer architecture course, where we could use existing code such as a register file or program counter as a baseline. The central idea was that we would have a register file and program counter for each task, and have a control module which would switch between the five tasks based on if they were complete, missed their deadline, or were ready to be used. In the RMS protocol, the task with the lowest period has the highest priority, and is able to preempt currently running tasks when the period refreshes, meaning we had to enable this context switching in our control module. We also included a standard up counter to monitor the current time, as a reference for when each task should become active again. The main benefit of this design was that context switching could occur in a single cycle, which can be much more efficient than a software implementation, and could still be reconfigurable at compile time with the use of an FPGA instead of an ASIC. <br><br>

                    &#8195;
                    Each designed module was tested functionally individually, and we followed integration testing with Verilog testbenches also. When that was complete, we integrated our design onto my Basys 3 FPGA Development board, which has a Xilinx Artix-7 FPGA board. Using the OLED display interface I designed in Summer 2023, we were able to create a display monitor to show the state of each task, including its stored register value, computation time, and if it was complete. Alongisde this, we displayed the current time, which task was currently active, and if the time was at the least common multiple of all task periods, meaning the entire schedule would reset. This design proved the feasibility of a hardware based task scheduler on a reconfigurable FPGA, and further work could be done in comparison to software schedulers in terms of context switching, power consumption, area requirements, timing, and design time. <br><br>

                    <h4>Documentation</h4>
                    <ul>
                        <li><a href="pdf/fpga_task_scheduler/Project_Proposal.pdf">Project Proposal</a></li>
                        <li><a href="pdf/fpga_task_scheduler/Presentation.pdf">Presentation</a></li>
                        <li><a href="pdf/fpga_task_scheduler/Final_Report.pdf">Final Report</a></li>
                    </ul>
    
                    </General>

            </div>

            <div id="tab3" class="tabcontent">

                <Header>
                    <h3>OpenFPGA Research</h3>
                </Header>

                <General>
                    As a 1 credit independent study during my Graduate concurrent semester in the Fall 2023 term, I worked with Dr. Duwe to do some research on the open-source tool OpenFPGA. This tool is unique in that it allows you to define FPGA architectures using XML files with tools such as VPR, VTR, and FPGA-Spice, to generate and simulate Verilog and SPICE netlists for varying FPGA architectures. The main goal of OpenFPGA is to combine multiple different FPGA architecture tools in one package to allow for shorter development time, due to the nature of high development times to design FPGAs and following netlist generation. Due to this, in their papers, they have reported that designs have become more streamlined due to high development times. By utilizing this tool, it should be easier for both commercial and open-source developers to create FPGA fabric netlists and generate place and route outputs with a faster turn around time. <br><br>

                    &#8195;
                    For this research, I began by reading over the background research papers surrounding OpenFPGA and reading through their online documentation. I was able to learn more about what made up an FPGA fabric, and what different design considerations an engineer must make when determining the right FPGA architecture. This was extremely beneficial to me, since I have worked on developing RTL for FPGAâ€™s for multiple years now, and it helped to give me a better understanding of place and route techniques after taking a digital VLSI course and my open-source digital ASIC fabrication senior design project. <br><br>
    
                    &#8195;
                    I also spent some time working with the OpenFPGA git repository and tools directly. For this, I learned how to install the proper dependencies and build the git repo, alongside utilizing a Docker instance to run precompiled binaries for the toolflow. I ran multiple testbench configurations, and learned that OpenFPGA has two different types of testbench procedures which are fully automated. A user can provide functional Verilog benchmarks, which can be either reconfigured onto the FPGA in an initial configure mode or compared with a direct mapped netlist inside the FPGA. The testbench which requires flashing a bitstream takes much longer, but is useful to verify the FPGA fabric can generate a proper bitstream and generate the same matching output to a target functional Verilog benchmark. To run a testbench, I had to also generate an FPGA Verilog fabric netlist, in which multiple different XML files can be referenced to alter the FPGA architecture description. <br><br>
    
                    &#8195;
                    Finally, I learned how to alter the cells referenced in the FPGA XML architecture description files. I ran through two documented processes for this, including using a custom functional Verilog module and an open-source cell from the same Skywater 130nm PDK that I utilized for my senior design project. Both of these Verilog designs can be referenced on the path directly in the XML files, and will then be able to be included for the proper module name when the total FPGA Verilog fabric netlist is generated through the OpenFPGA toolflow. This is extremely beneficial, since you can then use custom cells such as the open-source Skywater 130nm PDK, which can be carried through after synthesis for place and route generation and fabrication. 
    
                    <h4>Documentation</h4>
                    <ul>
                        <li><a href="pdf/openfpga/OpenFPGA_Research.pdf">Research Report</a></li>
                    </ul>
                </General>

            </div>

        </div>

        <div class=footer>
            <a href="https://www.linkedin.com/in/jake-hafele-6754511aa/" target="_blank" class="fa fa-linkedin"></a>
            <a href="https://www.youtube.com/channel/UCH2XCofc5pujRzQc8IvCcXg" target="_blank"
                class="fa fa-youtube"></a>
        </div>

    </div>

    <script type="text/javascript" src="./script/myScript.js"></script>
</body>

</html>