<!DOCTYPE html>
<html lang="en">

<head>
    <title>Jake Hafele - Project Portfolio</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="./style/myStyle.css" rel="stylesheet" type="text/css">
    <link rel="icon" href="logo/logo.png">
</head>

<body class="body">

    <div class="content">

        <div class="titleBlock">
            <a>Jake Hafele - Project Portfolio</a>
        </div>

        <div class="pageNav">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="resume.html">Resume</a></li>
                <li class="dropdown">
                    <a href="">Projects</a>
                    <div class="dropdown-content">
                        <a href="freshmanProject.html">Freshman Year</a>
                        <a href="sophomoreProject.html">Sophomore Year</a>
                        <a href="juniorProject.html">Junior Year</a>
                        <a href="seniorProject.html">Senior Year</a>
                    </div>
                </li>
                <li class="dropdown">
                    <a href="">Work Experience</a>
                    <div class="dropdown-content">
                        <a href="intern.html">Internships</a>
                        <a href="TA.html">Teaching Assistant</a>
                    </div>
                </li>
                <li><a href="reflection.html">Reflections</a></li>
            </ul>
        </div>

        <div class="contentNav">
            <ul>
                <li class="tablinks" onclick="openTab(event, 'tab1')"><a>Overview</a></li>
                <li class="tablinks" onclick="openTab(event, 'tab2')"><a>Single Cycle</a></li>
                <li class="tablinks" onclick="openTab(event, 'tab3')"><a>5 Stage</a></li>
                <li class="tablinks" onclick="openTab(event, 'tab4')"><a>FPGA Wrapper</a></li>
            </ul>
        </div>

        <div class="contentBlock">
            <div id="tab1" class="tabcontent">
                <Header>
                    Project Overview
                </Header>

                <General>
                    During the Spring 2023 school semester, I took my first Computer Architecture class, CprE 381, at
                    Iowa State University. In this class, we learned how to convert basic programs into assembly, design
                    and analyze a MIPS processor, and compare different cache designs. In the lab portion of the class,
                    we focused on implementing three different MIPS processors using VHDL and ModelSim, including a
                    single cycle, 5 stage software pipeline, and 5 stage hardware pipeline processor. We started with
                    the single cycle processor, and designed modules to increment the program counter, decode
                    instructions, a register file, a sign extender, and an ALU. For the 5 stage processors, we broke
                    apart each of these components into five separate stages, so that we could reduce the critical path
                    latency and improve the maximum clock rate of our design. Near the end of the project, me and my
                    partner had about a month of time left. Due to this, we decided to work on an extra credit project
                    through the form of an FPGA wrapper with the Altera DE2 FPGA Development board. For more information
                    on each of these designs, please look at the other tabs for this project. <br><br>

                    &#8195;
                    The goal of this project was to learn more about implementing specific components of a processor,
                    and analyzing the performance tradeoffs between each of our three processors. For the software
                    pipeline, we inserted NOP instructions to remove the risk of data and control dependencies within
                    our pipeline. This led to an increased number of instructions, which made our overall execution time
                    larger. As we implemented stalling in the pipeline registers of our hardware pipeline, we were able
                    to reduce the number of instructions used, with the tradeoff of our CPI increasing from a near
                    average of 1. After adding forwarding we were able to reduce the average CPI of our hardware
                    pipeline while retaining a faster maximum clock frequency compared to our single cycle design. By
                    analyzing these choices, we were able to make educated design decisions on how to improve our HW
                    pipeline design, and yield an improved performance compared to our first two processor designs.
                    <br><br>

                    &#8195;
                    Another goal of the project was to take ownership in our required work by taking it a step further
                    with an extra credit project. As mentioned before, we had extra time near the end of the semester,
                    so me and my partner Thomas worked on designing an FPGA wrapper for the Altera DE2 FPGA development
                    board. With this, we were able to combine Verilog code from our previous digital design class, that
                    I also was a teaching assistant for, and a mix of FPGA modules, from the previous library I
                    designed, to make a robust wrapper. It was very satisfying to combine designs for clock dividers,
                    button debouncers, and seven segment display interfaces that had already been extensively tested,
                    and apply them to an interesting and challenging MIPS processor design. This was also a fantastic
                    goal and achievement since we were finally able to see our processor run on real hardware, and not
                    just the required simulations for the course and lab. For more information, please reference the
                    FPGA tab on this page. <br><br>

                    <h4>Design Reports</h4>
                    <ul>
                        <li><a href="./pdf/MIPSProcessor/Reports/Single Cycle Processor Design Report.pdf">Single Cycle
                                Design Report</a></li>
                        <li><a href="./pdf/MIPSProcessor/Reports/5 Stage Processor Design Report.pdf">Multistage
                                Pipeline Design Report</a></li>
                        <li><a href="./pdf/MIPSProcessor/Reports/Performance Analysis.pdf">Performance Analysis</a></li>
                        <li><a href="./pdf/MIPSProcessor/Reports/FPGA Synthesis Report.pdf">FPGA Wrapper Report</a></li>
                    </ul>

                    <h4>Controls Spreadsheets</h4>
                    <ul>
                        <li><a href="./pdf/MIPSProcessor/Controls_Sheets/Single Cycle Controls.xlsx">Single Cycle
                                Controls</a></li>
                        <li><a href="./pdf/MIPSProcessor/Controls_Sheets/5 Stage SW Controls.xlsx">Software Pipeline
                                Controls</a></li>
                        <li><a href="./pdf/MIPSProcessor/Controls_Sheets/5 Stage HW Controls.xlsx">Hardware Pipeline
                                Controls</a></li>
                    </ul>

                </General>

            </div>

            <div id="tab2" class="tabcontent">
                <Header>
                    Single Cycle
                </Header>

                <General>
                    The first main project that we completed in CprE 381 was our MIPS single cycle processor. This
                    processor would take 32-bit instructions, and was able to decode multiple R-type, I-type, and J-type
                    instructions, including ALU arithmetic operations, conditional branches, unconditional branches, and
                    memory operations. A full list of the 33 instructions and their respective decoded control signals
                    can be seen below in the Single Cycle Controls spreadsheet. To implement this processor, we designed
                    an ALU, register file, control decode, and sign extender. We were provided instantiated RAM modules
                    to act as memory to interface with the provided testing toolflow. Using the open-source MIPS
                    simulator MARS, and simulations from Quartus Prime and ModelSim, we would be able to load assembly
                    instructions into our processor and verify expected behavior every clock cycle. <br><br>

                    &#8195;
                    Each of our designed modules were written with VHDL, with a combination of structural, dataflow, and
                    behavioral models. All of our code was managed with revision control by using Git, and we installed
                    a VHDL plugin to use with VS Code as our text editor. As mentioned before, we used the open-source
                    MIPS ISA Simulator MARS to simulate and test the assembly programs we would design to later test on
                    our single cycle processor. <br><br>

                    &#8195;
                    During the previous labs before the project, we were tasked with implementing a register file and
                    basic ALU. The ALU could take an add/sub control, and we also included a 32 bit 2x1 multiplexor to
                    choose between the contents of a second register or an extended immediate value, to dictate
                    different ALU instructions between R-type and I-type. Since these were completed already, the main
                    tasks in the single cycle processor project were to create a more integrated ALU, an instruction
                    decode module, and a program incrementor module. The modules that I worked on were both the
                    instruction decode and program counter incrementor modules, while my teammate Thomas worked on
                    including additional functionality for our ALU, based on the added instructions. <br><br>

                    &#8195;
                    The first module I worked on designing was our instruction decode module. This module would take in
                    the upper 6 bits of each instruction fetched from instruction memory to determine what instruction
                    we would run. If the opcode was a 0, we also were required to read in the function of the
                    instruction, which was the 6 lowest bits of R-type instructions. Finally, we needed to read the RT
                    address to identify certain branch instructions, including bgez and bltz. By using a process
                    statement with these three inputs in the sensitivity list, I was able to create a branching case
                    statement based on the opcode, then potentially reading the function or RT address depending on the
                    opcode. Once we knew what the decoded instruction was, we were able to properly determine the
                    control signals for each instruction for the ALU, data memory, and register file. The specific
                    controls listed were created in a spreadsheet to manage better, and can be seen at the bottom of
                    this page. Since I designed this module, it was my partner Thomasâ€™s responsibility to test it with a
                    VHDL testbench. Expected outputs and waveform results can be seen in the Single Cycle Report below.
                    <br><br>

                    &#8195;
                    The next module I designed was the fetch module, to appropriately update the program counter for a
                    following instruction, conditional branches, and unconditional branches. We began by designing a
                    register to hold the program counter, which was a 32 bit value that could be asynchronously reset
                    and included a write enable bit. The fetch module would take in an input from the decoded control
                    module to multiplex between a PC + 4 address, branch address, or jump address, which were all
                    calculated separately based on the requirements of the MIPS ISA. Other inputs included the jump
                    address and branch determination to handle both unconditional and conditional branches. As before,
                    Thomas was responsible with testing this module. <br><br>

                    &#8195;
                    After Thomas was done completing the ALU, it was my responsibility to test it! This was an awesome
                    opportunity to test something that I had not designed, which I got lots of practice from on my co-op
                    as a Systems Engineer at Collins Aerospace. Our ALU would take in two inputs to use as arithmetic
                    operands, which could be received either from our register file or as a 16 bit extended immediate
                    value. Depending on what type of ALU instruction we had, the immediate could be extended as either
                    sign-extended or zero-extended. For example, ADDI instructions were sign-extended but logic
                    instructions like ANDI were zero-extended. We used more control signals to act as a select line for
                    a multiplexer between each of our ALU submodules to dictate the correct output. Each unit under test
                    inside of the ALU included branch determination, an adder, logic operations, and a shift module.
                    Each of these modules earned their own testbench, which included error flags and automated error
                    checking based on the inputs and expected outputs. We also were able to create a custom .DO file for
                    ModelSim to automate compiling our source files, adding waveforms, and fitting the screen to them
                    all. We even figured out how to color code them to make viewing the waveforms easier for our TA.
                    <br><br>

                    &#8195;
                    After all of our individual modules were tested, we were ready to wire them up and instantiate them
                    together in a top-level processor module. We would include each of our designed modules from the
                    previous sections and in our first 2 labs, alongside the provided memory module for the instruction
                    and data memory. The largest challenge was keeping track of all of the internal signals, since this
                    was the most involved digital design module me and my partner had designed up to now. To help with
                    this, we designed a top-level schematic connecting each module, and specifically labeled each signal
                    on that schematic. This was especially useful since we could then reference this schematic to
                    determine what signals were left to connect. After connecting our processor, we were ready to begin
                    simulating assembly programs. <br><br>

                    &#8195;
                    To test our processor, we would simulate assembly programs to run code for a Fibonacci sequence of
                    bubble sort. Alongside this, we were provided unit cases and other tests to verify the robustness of
                    our design. During all of these tests, we were able to debug and verify the functionality of ALU
                    operations, control flow, and memory operations. It was crucial to ensure that instructions such as
                    JAL and JR would function correctly, since instructions like these required additional hardware to
                    multiplex inputs to the register file. It was also especially helpful to have another custom DO file
                    to automatically load the generated waveform from our toolflow and add in all of the relevant
                    waveforms, including but not limited to the target read and write registers, ALU output, and program
                    counter. Connecting and verifying each of these modules gave a wholistic view on computer
                    architecture and allowed for more complexity that I was looking for in my first digital design
                    class. Next, we were ready to begin designing our first multistage pipelined design. <br><br>

                    <h4>References</h4>
                    <ul>
                        <li><a href="./pdf/MIPSProcessor/Reports/Single Cycle Processor Design Report.pdf">Single Cycle
                                Design Report</a></li>
                        <li><a href="./pdf/MIPSProcessor/Controls_Sheets/Single Cycle Controls.xlsx">Single Cycle
                                Controls</a></li>
                    </ul>
                </General>

            </div>

            <div id="tab3" class="tabcontent">
                <Header>
                    5 Stage Pipeline
                </Header>

                <General>

                    <h4>5-Stage Software Pipeline</h4>

                    
                    <h4>5-Stage Hardware Pipeline</h4>


                    <h4>References</h4>
                    <ul>
                        <li><a href="./pdf/MIPSProcessor/Reports/5 Stage Processor Design Report.pdf">Multistage
                                Pipeline Design Report</a></li>
                        <li><a href="./pdf/MIPSProcessor/Reports/Performance Analysis.pdf">Performance Analysis</a></li>
                        <li><a href="./pdf/MIPSProcessor/Controls_Sheets/5 Stage SW Controls.xlsx">Software Pipeline
                                Controls</a></li>
                        <li><a href="./pdf/MIPSProcessor/Controls_Sheets/5 Stage HW Controls.xlsx">Hardware Pipeline
                                Controls</a></li>

                    </ul>
                </General>

            </div>

            <div id="tab4" class="tabcontent">
                <Header>
                    FPGA Wrapper
                </Header>

                <General>


                    <h4>References</h4>
                    <ul>
                        <li><a href="./pdf/MIPSProcessor/Reports/FPGA Synthesis Report.pdf">FPGA Wrapper Report</a></li>
                    </ul>
                </General>

            </div>

            <div class="githubBox">
                <a href="https://github.com/JakeHafele101/5-Stage-MIPS-Processor" target="_blank">Github Repo</a>
            </div>

        </div>

        <div class=footer>
            <a href="https://www.linkedin.com/in/jake-hafele-6754511aa/" target="_blank" class="fa fa-linkedin"></a>
            <a href="https://www.youtube.com/channel/UCH2XCofc5pujRzQc8IvCcXg" target="_blank"
                class="fa fa-youtube"></a>
        </div>

    </div>

    <script type="text/javascript" src="./script/myScript.js"></script>
</body>

</html>